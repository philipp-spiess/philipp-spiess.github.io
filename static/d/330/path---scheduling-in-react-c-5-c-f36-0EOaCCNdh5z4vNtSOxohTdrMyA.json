{"data":{"site":{"siteMetadata":{"author":"Philipp Spiess"}},"markdownRemark":{"id":"790510e4-e8af-5ec2-9e57-cefd113a1d89","excerpt":"In modern applications, user interfaces often have to juggle multiple tasks at the same time. For example, a search component might need to respond to user…","html":"<p>In modern applications, user interfaces often have to juggle multiple tasks at the same time. For example, a search component might need to respond to user input while providing auto completion results, and an interactive dashboard might need to update charts while loading data from the server and sending analytics data to a backend.</p>\n<p>All these parallel steps can lead to slow and unresponsive interfaces and unhappy users, so let’s learn how we can fix this.</p>\n<h2>Scheduling in User Interfaces</h2>\n<p>Our users expect immediate feedback. Whether they are clicking on a button to open a modal or adding text to an input field, they don’t want to wait before seeing some kind of confirmation. For example, the button could show a modal and the input field could display the key that was typed.</p>\n<p>To visualize what happens when this is not the case, let’s take a look at the demo application that Dan Abramov presented at his talk, <a href=\"https://reactjs.org/blog/2018/03/01/sneak-peek-beyond-react-16.html\">Beyond React 16</a>, at JSConf Iceland 2018.</p>\n<p>The application works like this: The more you type into the input below, the more detailed the charts below will get. Since both of the updates (the input element and the chart) run at the same time, the browser has to do so much computation that it will drop some frames. This leads to noticeable delays and a bad user experience:</p>\n<p><video src=\"/blog/scheduling-in-react/sync-mode.mp4\" muted=\"true\" autoplay muted playsinline loop></video></p>\n<p>However, a version that prioritizes updating the input with new keystrokes will appear to the end user as though it’s running a lot faster. This is because users receive immediate feedback even though the same computation time is required:</p>\n<p><video src=\"/blog/scheduling-in-react/concurrent-mode.mp4\" muted=\"true\" autoplay muted playsinline loop></video></p>\n<p>Unfortunately, current user interface architectures make it non-trivial to implement prioritization. One way to work around this problem is by <a href=\"https://davidwalsh.name/javascript-debounce-function\">debouncing</a> the chart update. The problem with this approach is that the charts still render synchronously when the debounced callback fires, which will again cause the user interface to be unresponsive for some time. We can do better!</p>\n<h2>Browser Event Loop</h2>\n<p>Before we learn more about how proper prioritizing of updates can be achieved, let’s dig deeper and understand why the browser has issues with these kind of user interactions.</p>\n<p>JavaScript code is executed in one thread, meaning that only one line of JavaScript can be run at any given time. The same thread is also responsible for other document lifecycles, like layout and paint.<sup id=\"fnref-1\"><a href=\"#fn-1\" class=\"footnote-ref\">1</a></sup> This means that whenever JavaScript code runs, the browser is blocked from doing anything else.</p>\n<p>To keep the user interface responsive, we only have a very short timeframe before we need to be able to receive the next input events. At the Chrome Dev Summit 2018, Shubhie Panicker and Jason Miller gave a talk, <a href=\"https://developer.chrome.com/devsummit/schedule/scheduling-on-off-main-thread\">A Quest to Guarantee Responsiveness</a>. During the talk, they showed the following visualization of the browser’s run loop, in which we can see that we only have 16ms (on a typical 60Hz screen) before the next frame is drawn and the next event needs to be processed:</p>\n<p><a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/805b72e5fe22f38f3f794de9668a14cc/20647/event-loop-browser.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-wrapper\"\n    style=\"position: relative; display: block;  max-width: 700px; margin-left: auto; margin-right: auto;\"\n  >\n    <span\n      class=\"gatsby-resp-image-background-image\"\n      style=\"padding-bottom: 26.47754137115839%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAFCAYAAABFA8wzAAAACXBIWXMAABYlAAAWJQFJUiTwAAABUUlEQVQY002MSytEcRjG/7HTKDWfwMbOQlIspViZzJmbMzdSNm4bGcUxTnPmZi7JpNE0LKx8Ad/AEmVnShbCyDHjLjXh5z9jFt769Tw97/u8ImOskNZDpPTlBpm6N1bRohpaZIVwLExYj7G6FkELG1INIkacTDpBNptkM6mTWl9q9kMI0T+JCO4i1C2ENyd9EdEXRO9WyA3NM9s1zIIiyC+2k5mzUAhZGOkVstiksw8RKP51fdsyc6QRGxdYYqe0S0S8ROtYksPBJU78OxQGptkLtXC2b+Uo30HpwMqM7d/DHhsicY4lekxbVPbHnXYcdhuKxCV9wOtG9Thwe5x43FLHXbhcTlSpXtWNfWwURbHLW6Wxn5pQ8Xs9+JqIinmDeXfFY+WWz48qUOP58Y7qww2vLyZvrw+Y99d81d6pT7VSlrdlnqplbq8vZfLN3/w0+AWYoPS+zc2MWgAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n    ></span>\n    <img\n        class=\"gatsby-resp-image-image\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;box-shadow:inset 0px 0px 0px 400px white;\"\n        alt=\"The browser event loop starts by running input handlers. Then it runs animation frame callbacks, and it ends with document lifecycles (style, layout, paint). All of this should complete within one frame, which is approximately 16ms on a 60Hz display.\"\n        title=\"\"\n        src=\"/static/805b72e5fe22f38f3f794de9668a14cc/86e95/event-loop-browser.png\"\n        srcset=\"/static/805b72e5fe22f38f3f794de9668a14cc/c5d49/event-loop-browser.png 175w,\n/static/805b72e5fe22f38f3f794de9668a14cc/2d9fb/event-loop-browser.png 350w,\n/static/805b72e5fe22f38f3f794de9668a14cc/86e95/event-loop-browser.png 700w,\n/static/805b72e5fe22f38f3f794de9668a14cc/85f92/event-loop-browser.png 1050w,\n/static/805b72e5fe22f38f3f794de9668a14cc/28c2d/event-loop-browser.png 1400w,\n/static/805b72e5fe22f38f3f794de9668a14cc/20647/event-loop-browser.png 1692w\"\n        sizes=\"(max-width: 700px) 100vw, 700px\"\n      />\n  </span>\n  </a></p>\n<p>Most JavaScript frameworks (including the current version of React) will run updates synchronously. We can think of this behavior as a function <code class=\"language-text\">render()</code> that will only return once the DOM is updated. During this time, the main thread is blocked.</p>\n<h2>Problems with Current Solutions</h2>\n<p>With the information above, we can formulate two problems that we have to solve in order to get to more responsive user interfaces:</p>\n<ol>\n<li>\n<p><strong>Long-running tasks cause frame drops.</strong> We need to make sure all of our tasks are small and can be completed within a couple of milliseconds so that we can run them within one frame.</p>\n</li>\n<li>\n<p><strong>Different tasks have different priorities.</strong> In the example application above, we saw that prioritizing the user input leads to a better experience overall. To do this, we need a way to define the order and to schedule tasks accordingly.</p>\n</li>\n</ol>\n<h2>Concurrent React and the Scheduler</h2>\n<p><em>⚠️ Warning: The following APIs are not yet stable and will change. I will do my best to keep this post updated.</em></p>\n<p>To implement a properly scheduled user interface with React, we have to look into two upcoming React features:</p>\n<ul>\n<li>\n<p><strong>Concurrent React (also known as Time Slicing).</strong> With the help of the new <a href=\"https://www.youtube.com/watch?v=ZCuYPiUIONs\">Fiber architecture</a> rewrite that was released with React 16, React can now pause during rendering and yield<sup id=\"fnref-2\"><a href=\"#fn-2\" class=\"footnote-ref\">2</a></sup> to the main thread.</p>\n<p>We will hear more about Concurrent React in the future but for now it is important to understand that when this mode is enabled, React will split the synchronous rendering of our React components into pieces that are run over multiple frames.</p>\n<p>➡️ With this feature, we’re able to split long-running rendering tasks into small chunks.</p>\n</li>\n<li>\n<p><strong>Scheduler.</strong> The general general purpose cooperative main thread scheduler is developed by the React Core team and makes it possible to register callbacks with different priority levels in the browser.</p>\n<p>At the time of writing this article, the priority levels are:</p>\n<ul>\n<li><code class=\"language-text\">Immediate</code> for tasks that need to run synchronously.</li>\n<li><code class=\"language-text\">UserBlocking</code> (250ms timeout) for tasks that should run as the result of a user interaction (e.g. a button click).</li>\n<li><code class=\"language-text\">Normal</code> (5s timeout) for updates that don’t have to feel instantaneous.</li>\n<li><code class=\"language-text\">Low</code> (10s timeout) for tasks that can be deferred but must still complete eventually (e.g. an analytics notification).</li>\n<li><code class=\"language-text\">Idle</code> (no timeout) for tasks that do not have to run at all (e.g. hidden offscreen content).</li>\n</ul>\n<p>The timeouts for each priority level are necessary to make sure that lower priority work still runs even if we have so much higher priority work to do that the higher priority work could run continuously. In scheduling algorithms, this problem is referred to as <a href=\"https://en.wikipedia.org/wiki/Starvation_(computer_science)\">starvation</a>. The timeouts give us the guarantee that every scheduled task will eventually run. For example, we won’t miss a single analytics notification, even if we have ongoing animations in our app.</p>\n<p>Under the hood, the Scheduler will store all registered callbacks in a list ordered by the expiration time (which is the time at which the callback was registered plus the timeout of the priority level). Then, the Scheduler will itself register a callback that is run after the next frame is drawn by the browser.<sup id=\"fnref-3\"><a href=\"#fn-3\" class=\"footnote-ref\">3</a></sup> Within this callback, the Scheduler will execute as many of the registered callbacks until it’s time to render the next frame.</p>\n<p>➡️ With this feature, we can schedule tasks with different priorities.</p>\n</li>\n</ul>\n<h2>Scheduling in Action</h2>\n<p>Let’s see how we can use these features to make an app feel a lot more responsive. To do this, we’ll take a look at <a href=\"https://github.com/philipp-spiess/scheduletron3000\">ScheduleTron 3000</a>, an app I built that allows users to highlight a search term in a list of names. Let’s take a look at the initial implementation first:</p>\n<!-- prettier-ignore -->\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token comment\">// The app shows a search box and a list of names. The list is</span>\n<span class=\"token comment\">// controlled by the searchValue state variable, which is updated</span>\n<span class=\"token comment\">// by the search box.</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">App</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> <span class=\"token punctuation\">[</span>searchValue<span class=\"token punctuation\">,</span> setSearchValue<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> React<span class=\"token punctuation\">.</span><span class=\"token function\">useState</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">function</span> <span class=\"token function\">handleChange</span><span class=\"token punctuation\">(</span>value<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">setSearchValue</span><span class=\"token punctuation\">(</span>value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>\n    <span class=\"token operator\">&lt;</span>div<span class=\"token operator\">></span>\n      <span class=\"token operator\">&lt;</span>SearchBox onChange<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span>handleChange<span class=\"token punctuation\">}</span> <span class=\"token operator\">/</span><span class=\"token operator\">></span>\n      <span class=\"token operator\">&lt;</span>NameList searchValue<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span>searchValue<span class=\"token punctuation\">}</span> <span class=\"token operator\">/</span><span class=\"token operator\">></span>\n    <span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>div<span class=\"token operator\">></span>\n  <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">// The search box renders a native HTML input element and keeps</span>\n<span class=\"token comment\">// it controlled using the inputValue variable. When a new key</span>\n<span class=\"token comment\">// is pressed, it will first update the local inputValue, then it</span>\n<span class=\"token comment\">// will update the App component’s searchValue, and then it will</span>\n<span class=\"token comment\">// simulate an analytics notification to our servers.</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">SearchBox</span><span class=\"token punctuation\">(</span>props<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> <span class=\"token punctuation\">[</span>inputValue<span class=\"token punctuation\">,</span> setInputValue<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> React<span class=\"token punctuation\">.</span><span class=\"token function\">useState</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">function</span> <span class=\"token function\">handleChange</span><span class=\"token punctuation\">(</span>event<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> value <span class=\"token operator\">=</span> event<span class=\"token punctuation\">.</span>target<span class=\"token punctuation\">.</span>value<span class=\"token punctuation\">;</span>\n\n    <span class=\"token function\">setInputValue</span><span class=\"token punctuation\">(</span>value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    props<span class=\"token punctuation\">.</span><span class=\"token function\">onChange</span><span class=\"token punctuation\">(</span>value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">sendAnalyticsNotification</span><span class=\"token punctuation\">(</span>value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>\n    <span class=\"token operator\">&lt;</span>input\n      type<span class=\"token operator\">=</span><span class=\"token string\">\"text\"</span>\n      value<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span>inputValue<span class=\"token punctuation\">}</span>\n      onChange<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span>handleChange<span class=\"token punctuation\">}</span>\n    <span class=\"token operator\">/</span><span class=\"token operator\">></span>\n  <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\nReactDOM<span class=\"token punctuation\">.</span><span class=\"token function\">render</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&lt;</span>App <span class=\"token operator\">/</span><span class=\"token operator\">></span><span class=\"token punctuation\">,</span> container<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p><em>ℹ️ This example uses <a href=\"https://reactjs.org/docs/hooks-intro.html\">React Hooks</a>. If you’re not familiar with this new React feature, take a look at the <a href=\"https://codesandbox.io/s/j3zrqpzkr5\">CodeSandbox code</a>. Additionally, you might wonder why we use two different state variables for this example. We’ll find out why this is needed in a bit.</em></p>\n<p>Try it out! Type a name (e.g. “Ada Stewart”) in the search box below and see how it works:</p>\n<iframe src=\"https://codesandbox.io/embed/j3zrqpzkr5?fontsize=14&hidenavigation=1&view=preview\" style=\"width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;\" sandbox=\"allow-modals allow-forms allow-popups allow-scripts allow-same-origin\"></iframe>\n<p>You might notice that the interface is not very responsive. To amplify the issue, I artificially slowed down the rendering time of the names list. And since this list is big, it has a significant impact on the application’s performance. This is not good 😰.</p>\n<p>Our users expect immediate feedback, but the app is unresponsive for quite some time after a keystroke. To understand what’s going on, let’s take a look at the DevTools’ Performance tab. Here’s a screenshot of a recording I made while I type the name “Ada” into the search box:</p>\n<p><a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/d8e525b8fc31fdba90634f8577da8301/27654/devtools-sync.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-wrapper\"\n    style=\"position: relative; display: block;  max-width: 700px; margin-left: auto; margin-right: auto;\"\n  >\n    <span\n      class=\"gatsby-resp-image-background-image\"\n      style=\"padding-bottom: 49.9223602484472%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAABYlAAAWJQFJUiTwAAACV0lEQVQozzWPW08TURSF5+cZBMQn/4E/w5iAQCAx8ckYhRcMSmpRUaCFliISxRcUlBbazrRzZubMrbfpHUryeTrGh5WdvfZaa++t2baN67qMq+/7OI6D53kxF4Zh3Avpcl7UMRw37l35rwZBEHvGaLfbca8JYWFZAlMIHOmoalIql5FSEkURzXoTT/rUw4YK8dB1Pda4nqvgEdbCOFCqAwzDQLNMZVabLdNCqFBLLXAsG9OU1OUfOsY6bf0tAzOh6hss/TwOrlaqmFWBrbSxV8HQVWDgq62iRNm5xI8cdOcKKzSQTYuKzFOPiljuGVfl79RaRQxZQIQVNbcpWYVYJwKDilui6ulovjpdiDydfsj1bcRw1KJ33aR/06I/rKsaMRh16A5Vf9OJ+96wwWAYxtr/GOsbkYc2uh3SKhygv39GeesJMr2Ev6eQWqRbTuHkEhSTs1S3Fwgzy3ipBerHz2n/PKCUfKo8c8jUUsyHX1+g3QLDmo3Yn6eSeYzIzhL9WKZ9Ms+oUaZxto2VfYTIzVP7tkRH8b3COsPQxskuKH4O58ui0qsDfq+geWETM79D6dcG4iJB3dik6+4xUGgaWVw9TWCk6Ln7DLx9+v4+XbGHX87g6bu0rDTXQYael2bgHKF1+30KOw84TdzBysxQO57BPZwiOJjC/HSf0+Rd8luTBEf38A6n8Y+m1HuT5D9Mq9mE+mya8GjsmaCee4jW6V1TTK9z8fEll59X0HfXsLPvcHOb6p2k4l8pfpWr7VVl3kAeJJGHSYqp1/GsqPjSzhpOJoF/kuYvFv+4w++AdNAAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n    ></span>\n    <img\n        class=\"gatsby-resp-image-image\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;box-shadow:inset 0px 0px 0px 400px white;\"\n        alt=\"Screenshot of Chrome DevTools that shows that the three keypress events take 733ms to render.\"\n        title=\"\"\n        src=\"/static/d8e525b8fc31fdba90634f8577da8301/86e95/devtools-sync.png\"\n        srcset=\"/static/d8e525b8fc31fdba90634f8577da8301/c5d49/devtools-sync.png 175w,\n/static/d8e525b8fc31fdba90634f8577da8301/2d9fb/devtools-sync.png 350w,\n/static/d8e525b8fc31fdba90634f8577da8301/86e95/devtools-sync.png 700w,\n/static/d8e525b8fc31fdba90634f8577da8301/85f92/devtools-sync.png 1050w,\n/static/d8e525b8fc31fdba90634f8577da8301/28c2d/devtools-sync.png 1400w,\n/static/d8e525b8fc31fdba90634f8577da8301/ab2ea/devtools-sync.png 2100w,\n/static/d8e525b8fc31fdba90634f8577da8301/27654/devtools-sync.png 2576w\"\n        sizes=\"(max-width: 700px) 100vw, 700px\"\n      />\n  </span>\n  </a></p>\n<p>We can see there are a lot of red triangles, which is usually not a good sign. For every keystroke, we see a <code class=\"language-text\">keypress</code> event being fired. All three events run within one frame,<sup id=\"fnref-5\"><a href=\"#fn-5\" class=\"footnote-ref\">5</a></sup> which causes the duration of the frame to extend to <strong>733ms</strong>. That’s way above our average frame budget of 16ms.</p>\n<p>Inside this <code class=\"language-text\">keypress</code> event, our React code will be called, which causes the input value and the search value to update and then send the analytics notification. In turn, the updated state values will cause the app to rerender down to every individual name. That’s quite a lot of work that we have to do, and with this naive approach, it would block the main thread!</p>\n<p>The first step toward improving the status quo is to enable the unstable Concurrent Mode. This can be done by wrapping a part of our React tree with the <code class=\"language-text\">&lt;React.unstable_ConcurrentMode&gt;</code> component, like this<sup id=\"fnref-4\"><a href=\"#fn-4\" class=\"footnote-ref\">4</a></sup>:</p>\n<div class=\"gatsby-highlight\" data-language=\"diff\"><pre class=\"language-diff\"><code class=\"language-diff\"><span class=\"token deleted\">- ReactDOM.render(&lt;App />, container);</span>\n<span class=\"token inserted\">+ ReactDOM.render(</span>\n<span class=\"token inserted\">+  &lt;React.unstable_ConcurrentMode></span>\n<span class=\"token inserted\">+    &lt;App /></span>\n<span class=\"token inserted\">+  &lt;/React.unstable_ConcurrentMode>,</span>\n<span class=\"token inserted\">+  rootElement</span>\n<span class=\"token inserted\">+ );</span></code></pre></div>\n<p>However, enabling Concurrent Mode alone will not change the experience in our case. React will still receive both state updates at the same time, so there’s no way of knowing which is less important.</p>\n<p>We instead want to set the input value first so that we only need to update the search box in the beginning. Updates to the search value and our analytics notification should happen later. To do this, we’re using an API exposed by the Scheduler package (which can be installed with <code class=\"language-text\">npm i scheduler</code>) to enqueue a lower priority callback:</p>\n<div class=\"gatsby-highlight has-highlighted-lines\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"gatsby-highlight-code-line\"><span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> unstable_next <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">\"scheduler\"</span><span class=\"token punctuation\">;</span></span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">SearchBox</span><span class=\"token punctuation\">(</span>props<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> <span class=\"token punctuation\">[</span>inputValue<span class=\"token punctuation\">,</span> setInputValue<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> React<span class=\"token punctuation\">.</span><span class=\"token function\">useState</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">function</span> <span class=\"token function\">handleChange</span><span class=\"token punctuation\">(</span>event<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> value <span class=\"token operator\">=</span> event<span class=\"token punctuation\">.</span>target<span class=\"token punctuation\">.</span>value<span class=\"token punctuation\">;</span>\n\n    <span class=\"token function\">setInputValue</span><span class=\"token punctuation\">(</span>value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"gatsby-highlight-code-line\">    <span class=\"token function\">unstable_next</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span></span><span class=\"gatsby-highlight-code-line\">      props<span class=\"token punctuation\">.</span><span class=\"token function\">onChange</span><span class=\"token punctuation\">(</span>value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></span><span class=\"gatsby-highlight-code-line\">      <span class=\"token function\">sendAnalyticsNotification</span><span class=\"token punctuation\">(</span>value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></span><span class=\"gatsby-highlight-code-line\">    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></span><span class=\"gatsby-highlight-code-line\">  <span class=\"token punctuation\">}</span></span>\n  <span class=\"token keyword\">return</span> <span class=\"token operator\">&lt;</span>input type<span class=\"token operator\">=</span><span class=\"token string\">\"text\"</span> value<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span>inputValue<span class=\"token punctuation\">}</span> onChange<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span>handleChange<span class=\"token punctuation\">}</span> <span class=\"token operator\">/</span><span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Inside the API we’re using, <code class=\"language-text\">unstable_next()</code>, all React updates will be scheduled with the <code class=\"language-text\">Normal</code> priority, which is lower then the default priority inside an <code class=\"language-text\">onChange</code> listener.</p>\n<p>Indeed, with this change, our input box already feels a lot more responsive, and frames no longer get dropped while we’re typing. Let’s take another look at the Performance tab together:</p>\n<p><a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/a523aeacdf07611d54568ba07f655d9d/ec837/devtools-normal.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-wrapper\"\n    style=\"position: relative; display: block;  max-width: 700px; margin-left: auto; margin-right: auto;\"\n  >\n    <span\n      class=\"gatsby-resp-image-background-image\"\n      style=\"padding-bottom: 45.50387596899225%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAYAAAAywQxIAAAACXBIWXMAABYlAAAWJQFJUiTwAAACJElEQVQozy2PW1PTUBSF81N989URHR1fHN988QeAPojcdMALMwyWizDYAgKiMKI2bdokJzknl6Zp0rS0QuHzUH3Ys/ba+5s1extSSsIwRPo+URShlBr7IFC0Yu2lj5CKs3oTW2pO80EQjLkbPs8ziqKgm8XahxiO42DbNp4O9DwPW3urYaGimN7wkjTvE3cKLNen6bo0NXvDKx06PuB/eKh50zQxhPAQGrQbVXxP6tIXCQ05e+T2HB17iZ77mrhRwnFcXNvR30hcR/xjtQpX4OmculnHiGKFUDYyEVheDTewxr2M6sStXzrkiCCp4vo/CFJJQ9ZRbQ9L6FnQREQOXuzomU+1+RPDFXVsYdK97JMN+/ixR7sb0bu+IB+NkG2F044pLgt6owG9qws6g4x2PyUd9Cmu/lCMhmM+PS8wbHOT2HxHuLtMtD1FdPCS4GQOuTFDUp5EbS5w8nEa52iZuLxA9uUF4fYCrfIU3f3nZHtTZFrzvUmy4zcY+fk1F1cQHCyiVm+T1pZIlIm38pBo667WB5xVZqg5NeTxFv7pKt7JGnHlCenOhK57pOX7Wu+QHz/D8K1dkrBOJMooc46w+Yl+u0o/KjGI1xhEK7TUPnlaI1fbZHKTTK3r/YberzNMtLa0tkoM0wpGrXSLpDqN+L1D43AWt/IY8XkC63AeeTqvr1nidP0R6ugp9rdFvO+zmnuF83WWdvUtndp7EvPDuE8ba/wFmV+AFhvfpCUAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n    ></span>\n    <img\n        class=\"gatsby-resp-image-image\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;box-shadow:inset 0px 0px 0px 400px white;\"\n        alt=\"Screenshot of Chrome DevTools that shows that React breaks the rendering work down into small chunks. All frames can be drawn very quickly, although the analytics notifications are still sent in the middle of the rendering work.\"\n        title=\"\"\n        src=\"/static/a523aeacdf07611d54568ba07f655d9d/86e95/devtools-normal.png\"\n        srcset=\"/static/a523aeacdf07611d54568ba07f655d9d/c5d49/devtools-normal.png 175w,\n/static/a523aeacdf07611d54568ba07f655d9d/2d9fb/devtools-normal.png 350w,\n/static/a523aeacdf07611d54568ba07f655d9d/86e95/devtools-normal.png 700w,\n/static/a523aeacdf07611d54568ba07f655d9d/85f92/devtools-normal.png 1050w,\n/static/a523aeacdf07611d54568ba07f655d9d/28c2d/devtools-normal.png 1400w,\n/static/a523aeacdf07611d54568ba07f655d9d/ab2ea/devtools-normal.png 2100w,\n/static/a523aeacdf07611d54568ba07f655d9d/ec837/devtools-normal.png 2580w\"\n        sizes=\"(max-width: 700px) 100vw, 700px\"\n      />\n  </span>\n  </a></p>\n<p>We see that the long-running tasks are now broken down into smaller ones that can be completed within a single frame. The red triangles that indicate frame drops are also gone.</p>\n<p>However, one thing that is still not ideal is that the analytics notification (highlighted in the above screenshot) is still executed with the rendering work. Since the users of our app do not see this task, we can schedule a callback with an even lower priority for that:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span>\n  unstable_LowPriority<span class=\"token punctuation\">,</span>\n  unstable_runWithPriority<span class=\"token punctuation\">,</span>\n  unstable_scheduleCallback\n<span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">\"scheduler\"</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">sendDeferredAnalyticsNotification</span><span class=\"token punctuation\">(</span>value<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">unstable_runWithPriority</span><span class=\"token punctuation\">(</span>unstable_LowPriority<span class=\"token punctuation\">,</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">unstable_scheduleCallback</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token function\">sendAnalyticsNotification</span><span class=\"token punctuation\">(</span>value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>If we now use <code class=\"language-text\">sendDeferredAnalyticsNotification()</code> in our search box component and take another look at the Performance tab with this change and zoom toward the end, we’ll see that our analytics are now sent after all rendering work has completed, and so all the tasks in our app are perfectly scheduled:</p>\n<p><a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/e5ef87ea4a1dc1f0ef5c1a52776ca343/3616a/devtools-normal-and-low.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-wrapper\"\n    style=\"position: relative; display: block;  max-width: 700px; margin-left: auto; margin-right: auto;\"\n  >\n    <span\n      class=\"gatsby-resp-image-background-image\"\n      style=\"padding-bottom: 45.69433669511248%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAYAAAAywQxIAAAACXBIWXMAABYlAAAWJQFJUiTwAAAB/klEQVQoz0WPa2sTURCG96fbogh+8KtIEbXUS6kVBdvQC5oKphdKIW2waXY32cs5e03TZLNJG9PN4+xK8cDDO2fmPTNzDK01URShlCKOY4IgIEkSojCkn6aEgcbTIS2rR09HPPhLLX0PjEajSg3P86pmnu/ji4ZhgNIBOopJ+tek1zfoZECn6+BLE9d1MU2TVIb1+33xh9WAMrZtG6Nnmyhp5rnS0CtRdNsNrPMadmsfp7VF5n5GOU2pySBfVR5f/KqKy7ee5HU1yLAdGxV5OGEXP/XoBTZ+bNG2znD0JY5qEaeiQUfqPj3xKVE3cuRND8u38BK3wlUuhpZVVRKQF7dMuRNmFaPZRHJ33DJnUlLW5xmT+Zh8nlc6no0YTgaSH1dkeYZhfn1F79sK1z8/kBxskNbfk9Tfia5XcVr/KLV1xvL1G1Vnlh5SnnzoErk/yOJTBr/rDC8PmOU3suH2Y+K9p0R7ywS7zwh2lvG2l/C35F57RLjzBF1bIu98p5BGi0UhLCiE+X1BUSy4F72fF9Ugw2t/IrK/oDubqPYG+mqTUbBLFgrBzj8N9xiGDYbROYOgyeT2j2yoGUVnkmuRJReiTabTHOOy8YbO0VuuDv/TOVrFOlnDlLx1sop5vEaz/hLraAXr+DX59A7fbNDcf073dI2L+gvav1bIhgl/AfrWiDNyENJJAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n    ></span>\n    <img\n        class=\"gatsby-resp-image-image\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;box-shadow:inset 0px 0px 0px 400px white;\"\n        alt=\"Screenshot of Chrome DevTools that show that React breaks the rendering work down into small chunks. Analytics are sent at the end after all rendering work has completed.\"\n        title=\"\"\n        src=\"/static/e5ef87ea4a1dc1f0ef5c1a52776ca343/86e95/devtools-normal-and-low.png\"\n        srcset=\"/static/e5ef87ea4a1dc1f0ef5c1a52776ca343/c5d49/devtools-normal-and-low.png 175w,\n/static/e5ef87ea4a1dc1f0ef5c1a52776ca343/2d9fb/devtools-normal-and-low.png 350w,\n/static/e5ef87ea4a1dc1f0ef5c1a52776ca343/86e95/devtools-normal-and-low.png 700w,\n/static/e5ef87ea4a1dc1f0ef5c1a52776ca343/85f92/devtools-normal-and-low.png 1050w,\n/static/e5ef87ea4a1dc1f0ef5c1a52776ca343/28c2d/devtools-normal-and-low.png 1400w,\n/static/e5ef87ea4a1dc1f0ef5c1a52776ca343/ab2ea/devtools-normal-and-low.png 2100w,\n/static/e5ef87ea4a1dc1f0ef5c1a52776ca343/3616a/devtools-normal-and-low.png 2578w\"\n        sizes=\"(max-width: 700px) 100vw, 700px\"\n      />\n  </span>\n  </a></p>\n<p>Try it out:</p>\n<iframe src=\"https://codesandbox.io/embed/v0lxm0xlzl?fontsize=14&hidenavigation=1&view=preview\" style=\"width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;\" sandbox=\"allow-modals allow-forms allow-popups allow-scripts allow-same-origin\"></iframe>\n<h2>Limitations of the Scheduler</h2>\n<p>With the Scheduler, it’s possible to control when callbacks are executed. It’s built deep into the latest React implementation and works out of the box with Concurrent mode.</p>\n<p>That said, there are two limitations of the Scheduler:</p>\n<ol>\n<li><strong>Resource Fighting.</strong> The Scheduler tries to use all of the resources available. This causes issues if multiple instances of a scheduler run on the same thread and compete for resources. We need to ensure that all parts of our application will use the same instance.</li>\n<li><strong>Balancing user-defined tasks with browser work.</strong> Since the Scheduler runs in the browser, it only has access to the APIs the browser exposes. Document lifecycles like rendering or garbage collection can interfere with the work in an uncontrollable way.</li>\n</ol>\n<p>To remove these limitations, the Google Chrome team is working together with React, Polymer, Ember, Google Maps, and the Web Standards Community to create a <a href=\"https://github.com/spanicker/main-thread-scheduling\">Scheduling API in the browser</a>. What an exciting time!</p>\n<h2>Conclusion</h2>\n<p>Concurrent React and the Scheduler allow us to implement scheduling of tasks in our user interface which will allow us to create highly responsive applications.</p>\n<p>The official release for these features will likely happen in <a href=\"https://reactjs.org/blog/2018/11/27/react-16-roadmap.html#react-16x-q2-2019-the-one-with-concurrent-mode\">Q2 2019</a>. Until then, you can play around with the unstable APIs, but be aware that they will change.</p>\n<p>If you want to be among the first to know when these APIs change or when documentation for the new features is written, subscribe to <a href=\"https://this-week-in-react.org\">This Week in React ⚛️</a>.</p>\n<div class=\"footnotes\">\n<hr>\n<ol>\n<li id=\"fn-1\">\n<p>The MDN web docs feature a great <a href=\"https://developer.mozilla.org/en-US/docs/Tools/Performance/Scenarios/Intensive_JavaScript\">article</a> about this issue.</p>\n<a href=\"#fnref-1\" class=\"footnote-backref\">↩</a>\n</li>\n<li id=\"fn-2\">\n<p>This is a fancy term for returning for a function that is able to resume. Check out <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/yield\">generator functions</a> for a similar concept.</p>\n<a href=\"#fnref-2\" class=\"footnote-backref\">↩</a>\n</li>\n<li id=\"fn-3\">\n<p>In the <a href=\"https://github.com/facebook/react/blob/master/packages/scheduler/src/forks/SchedulerHostConfig.default.js\">current implementation</a>, this is achieved by using <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Window/postMessage\"><code class=\"language-text\">postMessage()</code></a> inside a <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame\"><code class=\"language-text\">requestAnimationFrame()</code></a> callback. This will then be called right after the frame is rendered.</p>\n<a href=\"#fnref-3\" class=\"footnote-backref\">↩</a>\n</li>\n<li id=\"fn-4\">\n<p>There is also an alternative way to enable Concurrent Mode by using the new <a href=\"https://github.com/facebook/react/blob/1d48b4a68485ce870711e6baa98e5c9f5f213fdf/packages/react-dom/src/client/ReactDOM.js#L833-L853\"><code class=\"language-text\">createRoot()</code></a> API.</p>\n<a href=\"#fnref-4\" class=\"footnote-backref\">↩</a>\n</li>\n<li id=\"fn-5\">\n<p>After processing the first <code class=\"language-text\">keypress</code> event, the browser sees pending events in its queue and decides to run the event listener before rendering the frame.</p>\n<a href=\"#fnref-5\" class=\"footnote-backref\">↩</a>\n</li>\n</ol>\n</div>","frontmatter":{"title":"Scheduling in React","date":"March 15, 2019"},"fields":{"readingTime":{"text":"13 min read"}}}},"pageContext":{"slug":"/scheduling-in-react/","previous":null,"next":null}}