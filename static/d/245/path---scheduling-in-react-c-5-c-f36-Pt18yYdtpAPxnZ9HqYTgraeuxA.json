{"data":{"site":{"siteMetadata":{"author":"Philipp Spiess"}},"markdownRemark":{"id":"790510e4-e8af-5ec2-9e57-cefd113a1d89","excerpt":"In modern applications, user interfaces often have to juggle multiple parts at the same time: A search component needs to respond to user input while providing…","html":"<p>In modern applications, user interfaces often have to juggle multiple parts at the same time: A search component needs to respond to user input while providing auto completion results; An interactive dashboard needs to update the charts while loading data from the server and sending analytics data to your backend.</p>\n<p>All these parallel steps can lead to janky interfaces and unhappy users – Let’s learn how we can fix this.</p>\n<h2>Scheduling in User Interfaces</h2>\n<p><strong>Users expect immediate feedback.</strong> Wether a user is clicking on a button or adding text to an input field, they expect some kind of confirmation immediately. The button should show a modal, or the input field will display the key that was typed.</p>\n<p>To visualize this, let’s take a look at the demo application that Dan Abramov showed us at his talk <a href=\"https://reactjs.org/blog/2018/03/01/sneak-peek-beyond-react-16.html\">Beyond React 16</a> at JSConf Iceland 2018. The more you type into the input box above, the more detailed the charts below will get. Since both of those updates run at the same time, the input feels janky.</p>\n<p><video src=\"/blog/scheduling-in-react/sync-mode.mp4\" muted=\"true\" autoplay loop></video></p>\n<p>One thing that we can see in the example above is that it’s more important to update the text box with the user input than it is to update the carts. A version that prioritizes that will appear a lot more responsive to the end user:</p>\n<p><video src=\"/blog/scheduling-in-react/concurrent-mode.mp4\" muted=\"true\" autoplay loop></video></p>\n<p>Unfortunately, current user interface architectures makes it non trivial to implement this kind of prioritization. One way to solve this is by <a href=\"https://davidwalsh.name/javascript-debounce-function\">debouncing</a> the chart update. The problem with this is that the charts still render in one go synchronously when the debounced callback fires, which will again cause our user interface to take multiple seconds during which it is not responsive. We can do better!</p>\n<h2>Browser Event Loop</h2>\n<p>Before we learn more about concrete solutions, let’s dig deeper and understand why the browser has issues these kind of user interfaces.</p>\n<p>Most JavaScript code is executed on the same thread that is also responsible for other document lifecycles like layout and paint<sup id=\"fnref-1\"><a href=\"#fn-1\" class=\"footnote-ref\">1</a></sup>. This means that whenever your JavaScript code runs, the browser is blocked form doing anything else.</p>\n<p>To keep the user interface responsive, we only have a very short time frame before we need to be able to receive the next input events. In the browser run loop visualization<sup id=\"fnref-2\"><a href=\"#fn-2\" class=\"footnote-ref\">2</a></sup> below, you can see that we only have 16 milliseconds (on a typical 60Hz screen) before the next frame is drawn and the next events need to be processed.</p>\n<p><span\n    class=\"gatsby-resp-image-wrapper\"\n    style=\"position: relative; display: block;  max-width: 700px; margin-left: auto; margin-right: auto;\"\n  >\n    <span\n      class=\"gatsby-resp-image-background-image\"\n      style=\"padding-bottom: 26.47754137115839%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAFCAYAAABFA8wzAAAACXBIWXMAABYlAAAWJQFJUiTwAAABUUlEQVQY002MSytEcRjG/7HTKDWfwMbOQlIspViZzJmbMzdSNm4bGcUxTnPmZi7JpNE0LKx8Ad/AEmVnShbCyDHjLjXh5z9jFt769Tw97/u8ImOskNZDpPTlBpm6N1bRohpaZIVwLExYj7G6FkELG1INIkacTDpBNptkM6mTWl9q9kMI0T+JCO4i1C2ENyd9EdEXRO9WyA3NM9s1zIIiyC+2k5mzUAhZGOkVstiksw8RKP51fdsyc6QRGxdYYqe0S0S8ROtYksPBJU78OxQGptkLtXC2b+Uo30HpwMqM7d/DHhsicY4lekxbVPbHnXYcdhuKxCV9wOtG9Thwe5x43FLHXbhcTlSpXtWNfWwURbHLW6Wxn5pQ8Xs9+JqIinmDeXfFY+WWz48qUOP58Y7qww2vLyZvrw+Y99d81d6pT7VSlrdlnqplbq8vZfLN3/w0+AWYoPS+zc2MWgAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n    ></span>\n    <img\n        class=\"gatsby-resp-image-image\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;box-shadow:inset 0px 0px 0px 400px white;\"\n        alt=\"The browser event loop starts by running input handlers, followed by animation frame callbacks, and ends with document lifecycles (style, layout, paint). All of this should complete within one frame which is approximately 16 milliseconds on a 60Hz display.\"\n        title=\"\"\n        src=\"/static/805b72e5fe22f38f3f794de9668a14cc/b37ae/event-loop-browser.png\"\n        srcset=\"/static/805b72e5fe22f38f3f794de9668a14cc/d3f8c/event-loop-browser.png 175w,\n/static/805b72e5fe22f38f3f794de9668a14cc/ec30b/event-loop-browser.png 350w,\n/static/805b72e5fe22f38f3f794de9668a14cc/b37ae/event-loop-browser.png 700w,\n/static/805b72e5fe22f38f3f794de9668a14cc/607b8/event-loop-browser.png 1050w,\n/static/805b72e5fe22f38f3f794de9668a14cc/d8314/event-loop-browser.png 1400w,\n/static/805b72e5fe22f38f3f794de9668a14cc/c5b24/event-loop-browser.png 1692w\"\n        sizes=\"(max-width: 700px) 100vw, 700px\"\n      />\n  </span></p>\n<p>Most JavaScript frameworks (including the current version of React) will run updates synchronously. You can think of this as a function <code class=\"language-text\">render()</code> which will only return once the DOM was updated. During this time, the main thread is blocked.</p>\n<h2>Problems With Current Solutions</h2>\n<p>From all of the information above, we can formulate two problems that we have to solve in order to get more responsive user interfaces:</p>\n<ol>\n<li><strong>Long running tasks cause frame drops.</strong> We need to make sure our tasks are small and can be completed within a couple of milliseconds.</li>\n<li><strong>Different parts have different importance.</strong> In the example above you could see that prioritizing the input box leads to a better user experience. We need a way to schedule work.</li>\n</ol>\n<h2>Concurrent React and the Scheduler</h2>\n<p><em>⚠️ Warning: The following APIs are not stable yet and will change. I will do my best to keep this post updated.</em></p>\n<p>To implement a properly scheduled user interface with React, we have to look into two (still unstable) React features:</p>\n<ul>\n<li>\n<p><strong>Concurrent React (also known as Time Slicing).</strong> With the help of the new <a href=\"https://www.youtube.com/watch?v=ZCuYPiUIONs\">Fiber architecture</a> rewrite that got release with React v16, React can now pause rendering of large component trees and yield<sup id=\"fnref-3\"><a href=\"#fn-3\" class=\"footnote-ref\">3</a></sup> to the main thread before resuming.</p>\n<p>➡️ With this feature, we’re able to split long running rendering tasks into smaller chunks.</p>\n</li>\n<li>\n<p><strong>Scheduler.</strong> With a general purpose browser scheduler developed by the React Core team, it’s possible to register callbacks with different priority levels.</p>\n<p>The different priority levels come with a timeout. At the point of writing this article, we have:</p>\n<ul>\n<li><code class=\"language-text\">Immediate</code> for tasks that need to run now.</li>\n<li><code class=\"language-text\">UserBlocking</code> (250ms timeout) for tasks that should run as the result of a user interaction (e.g. a button click).</li>\n<li><code class=\"language-text\">Normal</code> (5s timeout) for rendering non-interactive parts.</li>\n<li><code class=\"language-text\">Low</code> (10s timeout) for tasks that can be deferred but must still complete (e.g. an analytics ping).</li>\n<li><code class=\"language-text\">Idle</code> (no timeout) for tasks that do not have to run. (e.g. offscreen content that is promoted to a higher priority when it becomes visible).</li>\n</ul>\n<p>The timeouts are necessary to make sure that lower priority work still runs at all even if you have so much higher priority work to do, that it could run continuously. In scheduling algorithms, this problem is refereed to as <a href=\"https://en.wikipedia.org/wiki/Starvation_(computer_science)\">starvation</a>. It gives us the guarantee that every timeout will eventually runs (e.g. we won’t miss a single analytics ping).</p>\n<p>➡️ With this feature, we’re can run tasks with different importance.</p>\n</li>\n</ul>\n<h3>Concurrent React</h3>\n<p>a</p>\n<p>a</p>\n<p>a</p>\n<p>a</p>\n<p>a</p>\n<p>a</p>\n<p>a</p>\n<p>a</p>\n<p>a</p>\n<p>a</p>\n<p>a</p>\n<p>a</p>\n<h2></h2>\n<div class=\"footnotes\">\n<hr>\n<ol>\n<li id=\"fn-1\">\n<p>The MDN web docs feature a great <a href=\"https://developer.mozilla.org/en-US/docs/Tools/Performance/Scenarios/Intensive_JavaScript\">article</a> about this issue.</p>\n<a href=\"#fnref-1\" class=\"footnote-backref\">↩</a>\n</li>\n<li id=\"fn-2\">\n<p>The graphic is based on work by Subhie Panicker’s and Jason Miller’s talk about <a href=\"https://developer.chrome.com/devsummit/schedule/scheduling-on-off-main-thread\">A Quest to Guarantee Responsiveness</a> at the Chrome Dev Summit 2018.</p>\n<a href=\"#fnref-2\" class=\"footnote-backref\">↩</a>\n</li>\n<li id=\"fn-3\">\n<p>A fancy term for returning for a function that is able to resume. Check out <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/yield\">generator functions</a> for a similiar concept.</p>\n<a href=\"#fnref-3\" class=\"footnote-backref\">↩</a>\n</li>\n</ol>\n</div>","frontmatter":{"title":"Scheduling in React","date":"March 15, 2019"},"fields":{"readingTime":{"text":"5 min read"}}}},"pageContext":{"slug":"/scheduling-in-react/","previous":null,"next":null}}